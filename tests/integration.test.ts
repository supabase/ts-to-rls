/**
 * Integration tests for RLS DSL
 *
 * Tests that policies generated by the DSL work correctly in a real PostgreSQL database.
 *
 * Prerequisites:
 * - Supabase CLI installed and running
 *   - Run `supabase start` to start local Supabase instance
 *   - Or set DATABASE_URL environment variable to override connection string
 */

import {
  describe,
  test,
  expect,
  beforeAll,
  afterAll,
  beforeEach,
} from "vitest";
import { Pool, Client, PoolClient } from "pg";
import { escapeLiteral } from "pg/lib/utils";
import { v4 as uuidv4 } from "uuid";
import {
  policy,
  policies,
  session,
  createPolicyGroup,
  policyGroupToSQL,
  column,
  alwaysTrue,
  hasRole,
  auth,
  from,
} from "../src/index";

// Database connection configuration
// Default to Supabase local instance (port 54322) if DATABASE_URL is not set
const DATABASE_URL =
  process.env.DATABASE_URL ||
  "postgres://postgres:postgres@localhost:54322/postgres";

let pool: Pool;
let adminClient: Client;
let testData: Awaited<ReturnType<typeof seedData>>;

/**
 * Setup database schema
 * Supabase CLI already provides auth schema and auth.uid() function
 * We use Supabase's built-in auth.uid() which reads from request.jwt.claim.sub
 */
async function setupDatabase(client: Client) {
  // Supabase's auth.uid() reads from request.jwt.claim.sub
  // We'll set that in setCurrentUser() function

  // Create test tables
  await client.query(`
    CREATE TABLE IF NOT EXISTS documents (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      user_id UUID NOT NULL,
      title TEXT NOT NULL,
      content TEXT,
      is_public BOOLEAN DEFAULT FALSE,
      tenant_id INTEGER,
      created_at TIMESTAMP DEFAULT NOW()
    );
  `);

  await client.query(`
    CREATE TABLE IF NOT EXISTS posts (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      user_id UUID NOT NULL,
      title TEXT NOT NULL,
      content TEXT,
      is_public BOOLEAN DEFAULT FALSE,
      status TEXT DEFAULT 'draft',
      created_at TIMESTAMP DEFAULT NOW()
    );
  `);

  await client.query(`
    CREATE TABLE IF NOT EXISTS tenant_data (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      tenant_id INTEGER NOT NULL,
      name TEXT NOT NULL,
      value TEXT,
      created_at TIMESTAMP DEFAULT NOW()
    );
  `);

  await client.query(`
    CREATE TABLE IF NOT EXISTS projects (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      created_by UUID NOT NULL,
      name TEXT NOT NULL,
      status TEXT DEFAULT 'active',
      created_at TIMESTAMP DEFAULT NOW()
    );
  `);

  await client.query(`
    CREATE TABLE IF NOT EXISTS project_members (
      project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
      user_id UUID NOT NULL,
      can_edit BOOLEAN DEFAULT FALSE,
      created_at TIMESTAMP DEFAULT NOW(),
      PRIMARY KEY (project_id, user_id)
    );
  `);

  await client.query(`
    CREATE TABLE IF NOT EXISTS user_roles (
      user_id UUID NOT NULL,
      role TEXT NOT NULL,
      created_at TIMESTAMP DEFAULT NOW(),
      PRIMARY KEY (user_id, role)
    );
  `);

  await client.query(`
    CREATE TABLE IF NOT EXISTS organizations (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      name TEXT NOT NULL,
      created_at TIMESTAMP DEFAULT NOW()
    );
  `);

  await client.query(`
    CREATE TABLE IF NOT EXISTS organization_members (
      organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
      user_id UUID NOT NULL,
      role TEXT DEFAULT 'member',
      created_at TIMESTAMP DEFAULT NOW(),
      PRIMARY KEY (organization_id, user_id)
    );
  `);

  // Enable RLS on all tables
  await client.query(`ALTER TABLE documents ENABLE ROW LEVEL SECURITY;`);
  await client.query(`ALTER TABLE posts ENABLE ROW LEVEL SECURITY;`);
  await client.query(`ALTER TABLE tenant_data ENABLE ROW LEVEL SECURITY;`);
  await client.query(`ALTER TABLE projects ENABLE ROW LEVEL SECURITY;`);
  await client.query(`ALTER TABLE project_members ENABLE ROW LEVEL SECURITY;`);
  await client.query(`ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;`);
  await client.query(
    `ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;`
  );

  // Grant permissions to authenticated role (Supabase's default role for RLS)
  await client.query(`
    GRANT ALL ON documents, posts, tenant_data, projects, project_members, user_roles, organizations, organization_members TO authenticated;
    GRANT ALL ON auth.users TO authenticated;
  `);
}

/**
 * Clean up database - drop all policies and tables
 */
async function cleanupDatabase(client: Client) {
  // Drop all policies
  await client.query(`
    DO $$
    DECLARE
      r RECORD;
    BEGIN
      FOR r IN (SELECT schemaname, tablename, policyname
                FROM pg_policies
                WHERE schemaname = 'public')
      LOOP
        EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(r.policyname) ||
                ' ON ' || quote_ident(r.schemaname) || '.' || quote_ident(r.tablename);
      END LOOP;
    END $$;
  `);

  // Drop tables (don't drop auth.users as it's managed by Supabase)
  await client.query(`DROP TABLE IF EXISTS organization_members CASCADE;`);
  await client.query(`DROP TABLE IF EXISTS organizations CASCADE;`);
  await client.query(`DROP TABLE IF EXISTS project_members CASCADE;`);
  await client.query(`DROP TABLE IF EXISTS projects CASCADE;`);
  await client.query(`DROP TABLE IF EXISTS user_roles CASCADE;`);
  await client.query(`DROP TABLE IF EXISTS tenant_data CASCADE;`);
  await client.query(`DROP TABLE IF EXISTS posts CASCADE;`);
  await client.query(`DROP TABLE IF EXISTS documents CASCADE;`);
  // Don't drop auth.users or auth schema - Supabase manages those
}

/**
 * Seed test data
 * Returns an object with generated IDs for use in tests
 */
async function seedData(client: Client) {
  // Generate UUIDs for all entities
  const user1Id = uuidv4();
  const user2Id = uuidv4();
  const user3Id = uuidv4();

  const doc1Id = uuidv4();
  const doc2Id = uuidv4();
  const doc3Id = uuidv4();
  const doc4Id = uuidv4();

  const post1Id = uuidv4();
  const post2Id = uuidv4();
  const post3Id = uuidv4();

  const tenant1Id = uuidv4();
  const tenant2Id = uuidv4();
  const tenant3Id = uuidv4();

  const project1Id = uuidv4();
  const project2Id = uuidv4();

  // Create test users
  await client.query(
    `INSERT INTO auth.users (id, email) VALUES ($1, 'user1@test.com');`,
    [user1Id]
  );
  await client.query(
    `INSERT INTO auth.users (id, email) VALUES ($1, 'user2@test.com');`,
    [user2Id]
  );
  await client.query(
    `INSERT INTO auth.users (id, email) VALUES ($1, 'admin@test.com');`,
    [user3Id]
  );

  // Create documents
  await client.query(
    `
    INSERT INTO documents (id, user_id, title, content, is_public, tenant_id) VALUES
    ($1, $5, 'User1 Private Doc', 'Content 1', FALSE, 1),
    ($2, $5, 'User1 Public Doc', 'Content 2', TRUE, 1),
    ($3, $6, 'User2 Private Doc', 'Content 3', FALSE, 1),
    ($4, $6, 'User2 Public Doc', 'Content 4', TRUE, 2);
  `,
    [doc1Id, doc2Id, doc3Id, doc4Id, user1Id, user2Id]
  );

  // Create posts
  await client.query(
    `
    INSERT INTO posts (id, user_id, title, content, is_public, status) VALUES
    ($1, $4, 'User1 Draft', 'Draft content', FALSE, 'draft'),
    ($2, $4, 'User1 Published', 'Published content', TRUE, 'published'),
    ($3, $5, 'User2 Draft', 'Draft content', FALSE, 'draft');
  `,
    [post1Id, post2Id, post3Id, user1Id, user2Id]
  );

  // Create tenant data
  await client.query(
    `
    INSERT INTO tenant_data (id, tenant_id, name, value) VALUES
    ($1, 1, 'Tenant 1 Data', 'Value 1'),
    ($2, 2, 'Tenant 2 Data', 'Value 2'),
    ($3, 1, 'Tenant 1 More Data', 'Value 3');
  `,
    [tenant1Id, tenant2Id, tenant3Id]
  );

  // Create projects and members
  await client.query(
    `
    INSERT INTO projects (id, created_by, name, status) VALUES
    ($1, $3, 'User1 Project', 'active'),
    ($2, $4, 'User2 Project', 'active');
  `,
    [project1Id, project2Id, user1Id, user2Id]
  );

  await client.query(
    `
    INSERT INTO project_members (project_id, user_id, can_edit) VALUES
    ($1, $3, TRUE),
    ($2, $4, FALSE);
  `,
    [project1Id, project2Id, user2Id, user1Id]
  );

  // Create user roles
  await client.query(
    `
    INSERT INTO user_roles (user_id, role) VALUES
    ($1, 'admin');
  `,
    [user3Id]
  );

  // Return IDs for use in tests
  return {
    users: {
      user1: user1Id,
      user2: user2Id,
      admin: user3Id,
    },
    documents: {
      user1Private: doc1Id,
      user1Public: doc2Id,
      user2Private: doc3Id,
      user2Public: doc4Id,
    },
    posts: {
      user1Draft: post1Id,
      user1Published: post2Id,
      user2Draft: post3Id,
    },
    tenants: {
      tenant1Data: tenant1Id,
      tenant2Data: tenant2Id,
      tenant1MoreData: tenant3Id,
    },
    projects: {
      user1Project: project1Id,
      user2Project: project2Id,
    },
  };
}

/**
 * Set current user context for a client
 * Sets request.jwt.claim.sub which Supabase's auth.uid() reads
 * Note: SET doesn't support parameterized queries, so we use string interpolation
 * with proper escaping via pg's escapeLiteral utility
 * Uses SET (session-level) instead of SET LOCAL (transaction-level) for tests
 */
async function setCurrentUser(
  client: Client | PoolClient,
  userId: string | null
) {
  if (userId) {
    // Supabase's auth.uid() reads from request.jwt.claim.sub
    await client.query(`SET request.jwt.claim.sub = ${escapeLiteral(userId)};`);
    // Also set app.current_user_id as fallback
    await client.query(`SET app.current_user_id = ${escapeLiteral(userId)};`);
  } else {
    await client.query(`RESET request.jwt.claim.sub;`);
    await client.query(`RESET app.current_user_id;`);
  }
}

/**
 * Set tenant context
 * Note: SET doesn't support parameterized queries, so we use string interpolation
 * with proper escaping via pg's escapeLiteral utility
 */
async function setTenant(client: Client | PoolClient, tenantId: number | null) {
  if (tenantId !== null) {
    // Use pg's escapeLiteral to safely escape the integer string
    // SET stores as text, type casting happens when reading via current_setting()
    await client.query(
      `SET app.current_tenant_id = ${escapeLiteral(tenantId.toString())};`
    );
  } else {
    await client.query(`RESET app.current_tenant_id;`);
  }
}

describe("RLS Integration Tests", () => {
  beforeAll(async () => {
    // Create connection pool
    pool = new Pool({ connectionString: DATABASE_URL });
    adminClient = new Client({ connectionString: DATABASE_URL });

    try {
      await adminClient.connect();
      await setupDatabase(adminClient);
    } catch (error) {
      console.error("Failed to connect to database:", error);
      console.error(
        "Make sure PostgreSQL is running and DATABASE_URL is correct"
      );
      throw error;
    }
  });

  afterAll(async () => {
    await cleanupDatabase(adminClient);
    await adminClient.end();
    await pool.end();
  });

  beforeEach(async () => {
    // Clean up policies before each test
    await adminClient.query(`
      DO $$
      DECLARE
        r RECORD;
      BEGIN
        FOR r IN (SELECT schemaname, tablename, policyname
                  FROM pg_policies
                  WHERE schemaname = 'public')
        LOOP
          EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(r.policyname) ||
                  ' ON ' || quote_ident(r.schemaname) || '.' || quote_ident(r.tablename);
        END LOOP;
      END $$;
    `);

    // Clean up indexes created by tests (only those starting with idx_)
    await adminClient.query(`
      DO $$
      DECLARE
        r RECORD;
      BEGIN
        FOR r IN (SELECT schemaname, tablename, indexname
                  FROM pg_indexes
                  WHERE schemaname = 'public'
                  AND indexname LIKE 'idx_%')
        LOOP
          EXECUTE 'DROP INDEX IF EXISTS ' || quote_ident(r.schemaname) || '.' || quote_ident(r.indexname);
        END LOOP;
      END $$;
    `);

    // Clear and reseed data
    await adminClient.query(
      `TRUNCATE TABLE organization_members, organizations, project_members, projects, user_roles, tenant_data, posts, documents CASCADE;`
    );
    await adminClient.query(`TRUNCATE TABLE auth.users CASCADE;`);
    testData = await seedData(adminClient);
  });

  describe("User Ownership Policies", () => {
    test("users can only SELECT their own documents", async () => {
      // Create policy using DSL
      const p = policy("user_docs_select")
        .on("documents")
        .for("SELECT")
        .when(column("user_id").isOwner());

      const policySQL = p.toSQL();

      await adminClient.query(policySQL);

      const user1Client = await pool.connect();
      await user1Client.query("SET ROLE authenticated;");
      await setCurrentUser(user1Client, testData.users.user1);

      const uidCheck = await user1Client.query("SELECT auth.uid() as uid;");
      expect(uidCheck.rows[0].uid).toBe(testData.users.user1);

      const user1Docs = await user1Client.query(
        "SELECT id, title FROM documents ORDER BY title;"
      );
      expect(user1Docs.rows).toHaveLength(2);
      expect(user1Docs.rows.map((r) => r.title)).toEqual([
        "User1 Private Doc",
        "User1 Public Doc",
      ]);
      user1Client.release();

      // Test as user2 - should see their own documents
      const user2Client = await pool.connect();
      await user2Client.query("SET ROLE authenticated;");
      await setCurrentUser(user2Client, testData.users.user2);
      const user2Docs = await user2Client.query(
        "SELECT id, title FROM documents ORDER BY title;"
      );
      expect(user2Docs.rows).toHaveLength(2);
      expect(user2Docs.rows.map((r) => r.title)).toEqual([
        "User2 Private Doc",
        "User2 Public Doc",
      ]);
      user2Client.release();
    });

    test("users can only INSERT documents with their own user_id", async () => {
      // Create policy using DSL
      const p = policy("user_docs_insert")
        .on("documents")
        .for("INSERT")
        .withCheck(column("user_id").isOwner());

      const policySQL = p.toSQL();
      await adminClient.query(policySQL);

      const user1Client = await pool.connect();
      await user1Client.query("SET ROLE authenticated;");
      await setCurrentUser(user1Client, testData.users.user1);

      await user1Client.query(
        `INSERT INTO documents (title, content, user_id) VALUES ('New Doc', 'Content', $1);`,
        [testData.users.user1]
      );

      await expect(
        user1Client.query(
          `INSERT INTO documents (title, content, user_id) VALUES ('Hacked Doc', 'Content', $1);`,
          [testData.users.user2]
        )
      ).rejects.toThrow();

      user1Client.release();
    });

    test("users can only UPDATE their own documents", async () => {
      // Create policy using DSL
      const p = policy("user_docs_update")
        .on("documents")
        .for("UPDATE")
        .when(column("user_id").isOwner())
        .withCheck(column("user_id").isOwner());

      const policySQL = p.toSQL();
      await adminClient.query(policySQL);

      const user1Client = await pool.connect();
      await user1Client.query("SET ROLE authenticated;");
      await setCurrentUser(user1Client, testData.users.user1);

      await user1Client.query(
        `UPDATE documents SET title = 'Updated Title' WHERE id = $1;`,
        [testData.documents.user1Private]
      );

      const hackResult = await user1Client.query(
        `UPDATE documents SET title = 'Hacked' WHERE id = $1;`,
        [testData.documents.user2Private]
      );
      expect(hackResult.rowCount).toBe(0);

      user1Client.release();
    });
  });

  describe("Public Access Policies", () => {
    test("users can SELECT public documents regardless of ownership", async () => {
      // Create policies: users can see their own OR public documents
      const ownPolicy = policy("user_own_docs")
        .on("documents")
        .for("SELECT")
        .when(column("user_id").isOwner());

      const publicPolicy = policies.publicAccess("documents");

      const ownSQL = ownPolicy.toSQL();
      const publicSQL = publicPolicy.toSQL();

      await adminClient.query(ownSQL);
      await adminClient.query(publicSQL);

      const user1Client = await pool.connect();
      await user1Client.query("SET ROLE authenticated;");
      await setCurrentUser(user1Client, testData.users.user1);

      const docs = await user1Client.query(
        "SELECT id, title, is_public FROM documents ORDER BY title;"
      );
      expect(docs.rows).toHaveLength(3); // 2 own + 1 public from user2
      expect(docs.rows.map((r) => r.title)).toEqual([
        "User1 Private Doc",
        "User1 Public Doc",
        "User2 Public Doc",
      ]);

      user1Client.release();
    });
  });

  describe("Tenant Isolation Policies", () => {
    test("users can only access data from their current tenant", async () => {
      // Create restrictive tenant isolation policy
      // Note: RESTRICTIVE policies require at least one PERMISSIVE policy to also pass
      // So we add a permissive policy that allows all (but restrictive will filter it)
      const permissivePolicy = policy("tenant_data_permissive")
        .on("tenant_data")
        .for("ALL")
        .when(alwaysTrue());

      const restrictivePolicy = policies.tenantIsolation("tenant_data");

      const permissiveSQL = permissivePolicy.toSQL();
      const restrictiveSQL = restrictivePolicy.toSQL();
      await adminClient.query(permissiveSQL);
      await adminClient.query(restrictiveSQL);

      const user1Client = await pool.connect();
      await user1Client.query("SET ROLE authenticated;");
      await setCurrentUser(user1Client, testData.users.user1);

      await setTenant(user1Client, 1);

      const tenant1Data = await user1Client.query(
        "SELECT id, name FROM tenant_data ORDER BY name;"
      );
      expect(tenant1Data.rows).toHaveLength(2);
      expect(tenant1Data.rows.map((r) => r.name)).toEqual([
        "Tenant 1 Data",
        "Tenant 1 More Data",
      ]);

      await setTenant(user1Client, 2);

      const tenant2Data = await user1Client.query(
        "SELECT id, name FROM tenant_data ORDER BY name;"
      );
      expect(tenant2Data.rows).toHaveLength(1);
      expect(tenant2Data.rows[0].name).toBe("Tenant 2 Data");

      user1Client.release();
    });
  });

  describe("Complex Conditions", () => {
    test("OR condition: users can see own posts OR public posts", async () => {
      const p = policy("posts_access")
        .on("posts")
        .for("SELECT")
        .when(column("user_id").isOwner().or(column("is_public").isPublic()));

      await adminClient.query(p.toSQL());

      const user1Client = await pool.connect();
      await user1Client.query("SET ROLE authenticated;");
      await setCurrentUser(user1Client, testData.users.user1);

      const posts = await user1Client.query(
        "SELECT id, title, is_public FROM posts ORDER BY title;"
      );
      expect(posts.rows).toHaveLength(2); // Own draft + own published + user2's published (if public)
      expect(posts.rows.map((r) => r.title)).toContain("User1 Draft");
      expect(posts.rows.map((r) => r.title)).toContain("User1 Published");

      user1Client.release();
    });

    test("AND condition: users can see own posts with specific status", async () => {
      const p = policy("posts_draft")
        .on("posts")
        .for("SELECT")
        .when(column("user_id").isOwner().and(column("status").eq("draft")));

      await adminClient.query(p.toSQL());

      const user1Client = await pool.connect();
      await user1Client.query("SET ROLE authenticated;");
      await setCurrentUser(user1Client, testData.users.user1);

      const drafts = await user1Client.query(
        "SELECT id, title, status FROM posts WHERE status = $1;",
        ["draft"]
      );
      expect(drafts.rows).toHaveLength(1);
      expect(drafts.rows[0].title).toBe("User1 Draft");

      user1Client.release();
    });
  });

  describe("Membership Conditions", () => {
    test("users can access projects they are members of", async () => {
      // Need a policy on project_members so the subquery can read it
      const membersPolicy = policy("project_members_select")
        .on("project_members")
        .for("SELECT")
        .when(alwaysTrue());

      const p = policy("project_member_access")
        .on("projects")
        .for("SELECT")
        .when(
          column("created_by")
            .isOwner()
            .or(column("id").isMemberOf("project_members", "project_id", "id"))
        );

      const policySQL = p.toSQL();
      const membersSQL = membersPolicy.toSQL();
      await adminClient.query(membersSQL);
      await adminClient.query(policySQL);

      const user1Client = await pool.connect();
      await user1Client.query("SET ROLE authenticated;");
      await setCurrentUser(user1Client, testData.users.user1);

      const projects = await user1Client.query(
        "SELECT id, name FROM projects ORDER BY name;"
      );
      expect(projects.rows).toHaveLength(2);
      expect(projects.rows.map((r) => r.name)).toEqual([
        "User1 Project",
        "User2 Project",
      ]);

      user1Client.release();
    });
  });

  describe("Role-Based Access", () => {
    test("users with admin role can access all data", async () => {
      const adminPolicy = policy("admin_full_access")
        .on("documents")
        .for("SELECT")
        .when(hasRole("admin"));

      const userPolicy = policy("user_own_docs")
        .on("documents")
        .for("SELECT")
        .when(column("user_id").isOwner());

      await adminClient.query(adminPolicy.toSQL());
      await adminClient.query(userPolicy.toSQL());

      const adminClient2 = await pool.connect();
      await adminClient2.query("SET ROLE authenticated;");
      await setCurrentUser(adminClient2, testData.users.admin);

      // Admin should see all documents
      const allDocs = await adminClient2.query(
        "SELECT id, title FROM documents ORDER BY title;"
      );
      expect(allDocs.rows).toHaveLength(4);

      adminClient2.release();
    });
  });

  describe("Policy Groups", () => {
    test("policy group applies multiple policies correctly", async () => {
      const group = createPolicyGroup("documents_crud", [
        policy("documents_select")
          .on("documents")
          .for("SELECT")
          .when(column("user_id").isOwner().or(column("is_public").isPublic())),
        policy("documents_insert")
          .on("documents")
          .for("INSERT")
          .withCheck(column("user_id").isOwner()),
        policy("documents_update")
          .on("documents")
          .for("UPDATE")
          .when(column("user_id").isOwner())
          .withCheck(column("user_id").isOwner()),
      ]);

      // Apply all policies from group
      const sql = policyGroupToSQL(group);
      const statements = sql.split(";").filter((s) => s.trim());
      for (const statement of statements) {
        if (statement.trim()) {
          await adminClient.query(statement.trim() + ";");
        }
      }

      const user1Client = await pool.connect();
      await user1Client.query("SET ROLE authenticated;");
      await setCurrentUser(user1Client, testData.users.user1);

      // Test SELECT
      const docs = await user1Client.query(
        "SELECT id, title FROM documents ORDER BY title;"
      );
      expect(docs.rows.length).toBeGreaterThan(0);

      // Test INSERT
      await user1Client.query(
        `INSERT INTO documents (title, content, user_id) VALUES ('New Doc', 'Content', $1);`,
        [testData.users.user1]
      );

      // Test UPDATE
      await user1Client.query(
        `UPDATE documents SET title = 'Updated' WHERE id = $1;`,
        [testData.documents.user1Private]
      );

      user1Client.release();
    });
  });

  describe("Session Variables", () => {
    test("policies work with session variables", async () => {
      const p = policy("session_based_access")
        .on("tenant_data")
        .for("SELECT")
        .when(
          column("tenant_id").eq(
            session.get("app.current_tenant_id", "integer")
          )
        );

      const policySQL = p.toSQL();
      await adminClient.query(policySQL);

      const user1Client = await pool.connect();
      await user1Client.query("SET ROLE authenticated;");
      await setCurrentUser(user1Client, testData.users.user1);

      await setTenant(user1Client, 1);

      const data = await user1Client.query("SELECT id, name FROM tenant_data;");
      expect(data.rows.length).toBeGreaterThan(0);
      expect(data.rows.every((r) => r.name.includes("Tenant 1"))).toBe(true);

      user1Client.release();
    });
  });

  describe("Edge Cases", () => {
    test("users without context cannot access protected data", async () => {
      const p = policy("protected_docs")
        .on("documents")
        .for("SELECT")
        .when(column("user_id").isOwner());

      await adminClient.query(p.toSQL());

      const noAuthClient = await pool.connect();
      await noAuthClient.query("SET ROLE authenticated;");
      // Don't set current user

      // Should see no documents (or get error if auth.uid() is null)
      try {
        const docs = await noAuthClient.query("SELECT id FROM documents;");
        // If no error, should be empty
        expect(docs.rows).toHaveLength(0);
      } catch (error) {
        // Or might throw error if auth.uid() returns null
        expect(error).toBeDefined();
      }

      noAuthClient.release();
    });

    test("restrictive policies work correctly", async () => {
      // Create restrictive tenant policy
      const restrictivePolicy = policy("restrictive_tenant")
        .on("tenant_data")
        .for("ALL")
        .restrictive()
        .when(
          column("tenant_id").eq(
            session.get("app.current_tenant_id", "integer")
          )
        );

      // Create permissive policy (should be blocked by restrictive)
      const permissivePolicy = policy("permissive_all")
        .on("tenant_data")
        .for("SELECT")
        .when(alwaysTrue());

      const restrictiveSQL = restrictivePolicy.toSQL();
      const permissiveSQL = permissivePolicy.toSQL();

      await adminClient.query(restrictiveSQL);
      await adminClient.query(permissiveSQL);

      const user1Client = await pool.connect();
      await user1Client.query("SET ROLE authenticated;");
      await setCurrentUser(user1Client, testData.users.user1);

      await setTenant(user1Client, 1);

      const data = await user1Client.query("SELECT id, name FROM tenant_data;");
      expect(data.rows.every((r) => r.name.includes("Tenant 1"))).toBe(true);

      user1Client.release();
    });
  });

  describe("Index Generation", () => {
    test("indexes are created when includeIndexes is true", async () => {
      const p = policy("user_docs_select")
        .on("documents")
        .for("SELECT")
        .when(column("user_id").eq(auth.uid()));

      const sql = p.toSQL({ includeIndexes: true });

      // Execute the SQL (should contain both policy and index)
      // Split by semicolon and filter out empty statements
      const statements = sql
        .split(";")
        .map((s) => s.trim())
        .filter((s) => s.length > 0);
      for (const statement of statements) {
        await adminClient.query(statement + ";");
      }

      // Verify index was created
      const indexResult = await adminClient.query(`
        SELECT indexname, tablename, indexdef
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'documents'
        AND indexname = 'idx_documents_user_id';
      `);

      expect(indexResult.rows).toHaveLength(1);
      expect(indexResult.rows[0].indexname).toBe("idx_documents_user_id");
      expect(indexResult.rows[0].tablename).toBe("documents");
      expect(indexResult.rows[0].indexdef).toContain("user_id");
    });

    test("indexes are NOT created when includeIndexes is false", async () => {
      const p = policy("user_docs_select_no_index")
        .on("documents")
        .for("SELECT")
        .when(column("user_id").eq(auth.uid()));

      const sql = p.toSQL({ includeIndexes: false });
      await adminClient.query(sql);

      // Verify index was NOT created
      const indexResult = await adminClient.query(`
        SELECT indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'documents'
        AND indexname = 'idx_documents_user_id';
      `);

      expect(indexResult.rows).toHaveLength(0);
    });

    test("indexes are NOT created when includeIndexes is undefined", async () => {
      const p = policy("user_docs_select_default")
        .on("documents")
        .for("SELECT")
        .when(column("user_id").eq(auth.uid()));

      const sql = p.toSQL(); // No options
      await adminClient.query(sql);

      // Verify index was NOT created
      const indexResult = await adminClient.query(`
        SELECT indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'documents'
        AND indexname = 'idx_documents_user_id';
      `);

      expect(indexResult.rows).toHaveLength(0);
    });

    test("indexes are created for isOwner helper", async () => {
      const p = policy("user_docs_isowner")
        .on("documents")
        .for("SELECT")
        .when(column("user_id").isOwner());

      const sql = p.toSQL({ includeIndexes: true });
      const statements = sql
        .split(";")
        .map((s) => s.trim())
        .filter((s) => s.length > 0);
      for (const statement of statements) {
        await adminClient.query(statement + ";");
      }

      // Verify index was created
      const indexResult = await adminClient.query(`
        SELECT indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'documents'
        AND indexname = 'idx_documents_user_id';
      `);

      expect(indexResult.rows).toHaveLength(1);
    });

    test("indexes are created for tenant isolation", async () => {
      const p = policy("tenant_data_select")
        .on("tenant_data")
        .for("SELECT")
        .when(column("tenant_id").belongsToTenant());

      const sql = p.toSQL({ includeIndexes: true });
      const statements = sql
        .split(";")
        .map((s) => s.trim())
        .filter((s) => s.length > 0);
      for (const statement of statements) {
        await adminClient.query(statement + ";");
      }

      // Verify index was created
      const indexResult = await adminClient.query(`
        SELECT indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'tenant_data'
        AND indexname = 'idx_tenant_data_tenant_id';
      `);

      expect(indexResult.rows).toHaveLength(1);
    });

    test("indexes are created for IN clause with subquery", async () => {
      // Need a policy on project_members so the subquery can read it
      const membersPolicy = policy("project_members_select")
        .on("project_members")
        .for("SELECT")
        .when(alwaysTrue());

      const p = policy("project_member_access")
        .on("projects")
        .for("SELECT")
        .when(
          column("id").in(
            from("project_members")
              .select("project_id")
              .where(column("user_id").eq(auth.uid()))
          )
        );

      const membersSQL = membersPolicy.toSQL({ includeIndexes: true });
      const policySQL = p.toSQL({ includeIndexes: true });

      // Execute both policies - split each separately to handle newlines properly
      const membersStatements = membersSQL
        .split(";")
        .map((s) => s.trim())
        .filter((s) => s.length > 0);
      const policyStatements = policySQL
        .split(";")
        .map((s) => s.trim())
        .filter((s) => s.length > 0);

      for (const statement of [...membersStatements, ...policyStatements]) {
        await adminClient.query(statement + ";");
      }

      // Verify indexes were created for both tables
      const projectsIndex = await adminClient.query(`
        SELECT indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'projects'
        AND indexname = 'idx_projects_id';
      `);

      const membersIndex = await adminClient.query(`
        SELECT indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'project_members'
        AND indexname = 'idx_project_members_user_id';
      `);

      expect(projectsIndex.rows).toHaveLength(1);
      expect(membersIndex.rows).toHaveLength(1);
    });

    test("indexes are created for multiple columns in same policy", async () => {
      // First add the organization_id column to documents table
      await adminClient.query(`
        ALTER TABLE documents ADD COLUMN IF NOT EXISTS organization_id UUID;
      `);

      const p = policy("multi_column_policy")
        .on("documents")
        .for("SELECT")
        .when(
          column("user_id")
            .eq(auth.uid())
            .or(column("organization_id").eq(session.get("app.org_id", "uuid")))
        );

      const sql = p.toSQL({ includeIndexes: true });
      const statements = sql
        .split(";")
        .map((s) => s.trim())
        .filter((s) => s.length > 0);
      for (const statement of statements) {
        await adminClient.query(statement + ";");
      }

      // Verify both indexes were created
      const userIndex = await adminClient.query(`
        SELECT indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'documents'
        AND indexname = 'idx_documents_user_id';
      `);

      const orgIndex = await adminClient.query(`
        SELECT indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'documents'
        AND indexname = 'idx_documents_organization_id';
      `);

      expect(userIndex.rows).toHaveLength(1);
      expect(orgIndex.rows).toHaveLength(1);
    });

    test("indexes are created for isMemberOf helper", async () => {
      const membersPolicy = policy("project_members_select")
        .on("project_members")
        .for("SELECT")
        .when(alwaysTrue());

      const p = policy("member_projects")
        .on("projects")
        .for("SELECT")
        .when(column("id").isMemberOf("project_members", "project_id"));

      const membersSQL = membersPolicy.toSQL({ includeIndexes: true });
      const policySQL = p.toSQL({ includeIndexes: true });

      // Split each SQL separately to handle newlines properly
      const membersStatements = membersSQL
        .split(";")
        .map((s) => s.trim())
        .filter((s) => s.length > 0);
      const policyStatements = policySQL
        .split(";")
        .map((s) => s.trim())
        .filter((s) => s.length > 0);

      for (const statement of [...membersStatements, ...policyStatements]) {
        await adminClient.query(statement + ";");
      }

      // Verify indexes were created
      const projectsIndex = await adminClient.query(`
        SELECT indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'projects'
        AND indexname = 'idx_projects_id';
      `);

      const membersProjectIdIndex = await adminClient.query(`
        SELECT indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'project_members'
        AND indexname = 'idx_project_members_project_id';
      `);

      const membersUserIdIndex = await adminClient.query(`
        SELECT indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'project_members'
        AND indexname = 'idx_project_members_user_id';
      `);

      expect(projectsIndex.rows).toHaveLength(1);
      expect(membersProjectIdIndex.rows).toHaveLength(1);
      expect(membersUserIdIndex.rows).toHaveLength(1);
    });

    test("indexes are created for policy groups", async () => {
      const group = createPolicyGroup("user_policies", [
        policy("user_docs")
          .on("documents")
          .for("SELECT")
          .when(column("user_id").eq(auth.uid())),
        policy("user_posts")
          .on("posts")
          .for("SELECT")
          .when(column("user_id").eq(auth.uid())),
      ]);

      const sql = policyGroupToSQL(group, { includeIndexes: true });
      const statements = sql.split(";").filter((s) => s.trim());
      for (const statement of statements) {
        if (statement.trim()) {
          await adminClient.query(statement.trim() + ";");
        }
      }

      // Verify indexes were created for both tables
      const docsIndex = await adminClient.query(`
        SELECT indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'documents'
        AND indexname = 'idx_documents_user_id';
      `);

      const postsIndex = await adminClient.query(`
        SELECT indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'posts'
        AND indexname = 'idx_posts_user_id';
      `);

      expect(docsIndex.rows).toHaveLength(1);
      expect(postsIndex.rows).toHaveLength(1);
    });

    test("IF NOT EXISTS prevents duplicate index errors", async () => {
      // Create policy first (without indexes)
      const p = policy("user_docs_select_if_not_exists")
        .on("documents")
        .for("SELECT")
        .when(column("user_id").eq(auth.uid()));

      await adminClient.query(p.toSQL());

      // Now create the index SQL separately
      const indexSQL = p.toSQL({ includeIndexes: true });
      const statements = indexSQL
        .split(";")
        .map((s) => s.trim())
        .filter((s) => s.length > 0);

      // Extract only index statements (skip policy creation)
      const indexStatements = statements.filter((s) =>
        s.toUpperCase().startsWith("CREATE INDEX")
      );

      // Execute index creation first time
      for (const statement of indexStatements) {
        await adminClient.query(statement + ";");
      }

      // Execute index creation second time - should not throw error due to IF NOT EXISTS
      await expect(async () => {
        for (const statement of indexStatements) {
          await adminClient.query(statement + ";");
        }
      }).not.toThrow();

      // Verify index still exists
      const indexResult = await adminClient.query(`
        SELECT indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'documents'
        AND indexname = 'idx_documents_user_id';
      `);

      expect(indexResult.rows).toHaveLength(1);
    });

    test("policies work correctly with generated indexes", async () => {
      const p = policy("user_docs_with_index")
        .on("documents")
        .for("SELECT")
        .when(column("user_id").eq(auth.uid()));

      const sql = p     .toSQL({ includeIndexes: true });
      const statements = sql
        .split(";")
        .map((s) => s.trim())
        .filter((s) => s.length > 0);
      for (const statement of statements) {
        await adminClient.query(statement + ";");
      }

      // Test that policy still works correctly
      const user1Client = await pool.connect();
      await user1Client.query("SET ROLE authenticated;");
      await setCurrentUser(user1Client, testData.users.user1);

      const user1Docs = await user1Client.query(
        "SELECT id, title FROM documents ORDER BY title;"
      );
      expect(user1Docs.rows).toHaveLength(2);
      expect(user1Docs.rows.map((r) => r.title)).toEqual([
        "User1 Private Doc",
        "User1 Public Doc",
      ]);

      user1Client.release();
    });
  });

  describe("Index Generation with Joins", () => {
    test("indexes are created for columns in join conditions", () => {
      // Create a policy with a subquery that has a join
      const p = policy("org_documents_access")
        .on("documents")
        .for("SELECT")
        .when(
          column("id").in(
            from("organizations", "org")
              .select("id")
              .join(
                "organization_members",
                column("org.id").eq("organization_members.organization_id"),
                "inner",
                "om"
              )
              .where(column("om.user_id").eq(auth.uid()))
          )
        );

      const sql = p.toSQL({ includeIndexes: true });

      // Verify indexes are generated in the SQL:
      // 1. documents.id (used in IN clause)
      // 2. organizations.id (used in join condition)
      // 3. organization_members.organization_id (used in join condition)
      // 4. organization_members.user_id (used in WHERE clause)

      expect(sql).toContain(
        "CREATE INDEX IF NOT EXISTS idx_documents_id ON documents (id)"
      );
      expect(sql).toContain(
        "CREATE INDEX IF NOT EXISTS idx_organizations_id ON organizations (id)"
      );
      expect(sql).toContain(
        "CREATE INDEX IF NOT EXISTS idx_organization_members_organization_id ON organization_members (organization_id)"
      );
      expect(sql).toContain(
        "CREATE INDEX IF NOT EXISTS idx_organization_members_user_id ON organization_members (user_id)"
      );
    });

    test("indexes are created for join conditions with table aliases", () => {
      // Create a policy with a subquery that has a join using aliases
      const p = policy("joined_projects_access")
        .on("projects")
        .for("SELECT")
        .when(
          column("id").in(
            from("projects", "p")
              .select("id")
              .join(
                "project_members",
                column("p.id").eq("pm.project_id"),
                "inner",
                "pm"
              )
              .where(column("pm.user_id").eq(auth.uid()))
          )
        );

      const sql = p.toSQL({ includeIndexes: true });

      // Verify indexes are generated for join condition columns (using actual table names, not aliases)
      expect(sql).toContain(
        "CREATE INDEX IF NOT EXISTS idx_projects_id ON projects (id)"
      );
      expect(sql).toContain(
        "CREATE INDEX IF NOT EXISTS idx_project_members_project_id ON project_members (project_id)"
      );
      expect(sql).toContain(
        "CREATE INDEX IF NOT EXISTS idx_project_members_user_id ON project_members (user_id)"
      );
    });

    test("indexes are created for left join conditions", () => {
      // Create a policy with a LEFT JOIN
      const p = policy("left_join_access")
        .on("documents")
        .for("SELECT")
        .when(
          column("id").in(
            from("organizations", "org")
              .select("id")
              .join(
                "organization_members",
                column("org.id").eq("organization_members.organization_id"),
                "left",
                "om"
              )
              .where(column("om.user_id").eq(auth.uid()))
          )
        );

      const sql = p.toSQL({ includeIndexes: true });

      // Verify indexes are generated for join condition (works for all join types)
      expect(sql).toContain(
        "CREATE INDEX IF NOT EXISTS idx_organizations_id ON organizations (id)"
      );
      expect(sql).toContain(
        "CREATE INDEX IF NOT EXISTS idx_organization_members_organization_id ON organization_members (organization_id)"
      );
    });

    test("indexes are created for complex join conditions with multiple columns", () => {
      // Create a policy with a join condition that uses multiple column comparisons
      // Note: This tests that join conditions are properly processed
      const p = policy("complex_join_access")
        .on("projects")
        .for("SELECT")
        .when(
          column("id").in(
            from("projects", "p")
              .select("id")
              .join(
                "project_members",
                column("p.id")
                  .eq("pm.project_id")
                  .and(column("p.status").eq("active")),
                "inner",
                "pm"
              )
              .where(column("pm.user_id").eq(auth.uid()))
          )
        );

      const sql = p.toSQL({ includeIndexes: true });

      // Verify indexes are generated for join condition columns
      // The join condition has p.id = pm.project_id, so both should be indexed
      expect(sql).toContain(
        "CREATE INDEX IF NOT EXISTS idx_projects_id ON projects (id)"
      );
      expect(sql).toContain(
        "CREATE INDEX IF NOT EXISTS idx_project_members_project_id ON project_members (project_id)"
      );
    });

    test("indexes for joins use actual table names not aliases", () => {
      // Verify that indexes generated for join conditions use actual table names,
      // not the aliases used in the subquery
      const p = policy("org_docs_policy")
        .on("documents")
        .for("SELECT")
        .when(
          column("id").in(
            from("organizations", "org")
              .select("id")
              .join(
                "organization_members",
                column("org.id").eq("organization_members.organization_id"),
                "inner",
                "om"
              )
              .where(column("om.user_id").eq(auth.uid()))
          )
        );

      const sql = p.toSQL({ includeIndexes: true });

      // Verify that indexes use actual table names (organizations, organization_members)
      // not aliases (org, om)
      expect(sql).toContain("idx_organizations_id ON organizations");
      expect(sql).toContain(
        "idx_organization_members_organization_id ON organization_members"
      );
      expect(sql).toContain(
        "idx_organization_members_user_id ON organization_members"
      );

      // Verify aliases are NOT used in index creation
      expect(sql).not.toContain("idx_org_");
      expect(sql).not.toContain("idx_om_");
      expect(sql).not.toContain("ON org (");
      expect(sql).not.toContain("ON om (");
    });
  });
});
